// <auto-generated>
// This file is referenced as external source. Do not modify.
// </auto-generated>

// Copyright (c) 2023 XstarS
// This file is released under the MIT License.
// https://opensource.org/licenses/MIT

#pragma warning disable
#nullable enable

#define INCRHASH_CHECK_DISPOSED
#define INCRHASH_DEBUG_CHECK_SUPPORTED

namespace System.Security.Cryptography
{
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Runtime.CompilerServices;
#if !(UNSAFE_HELPERS || NETCOREAPP3_0_OR_GREATER)
    using System.Runtime.InteropServices;
#endif

    /// <summary>
    /// Provides extension methods for <see cref="HashAlgorithm"/>
    /// for computing a hash value incrementally across several segments.
    /// </summary>
    [DebuggerNonUserCode, ExcludeFromCodeCoverage]
    internal static class IncrementalHashAlgorithm
    {
        /// <summary>
        /// Indicates whether the incremental hash extensions are supported by the current runtime.
        /// </summary>
        public static readonly bool IsSupported = IncrementalHashAlgorithm.CheckSupported();

        /// <summary>
        /// Appends the specified data into the hash algorithm for computing the hash.
        /// </summary>
        /// <param name="hashing">The <see cref="HashAlgorithm"/>.</param>
        /// <param name="buffer">The input to compute the hash for.</param>
        /// <exception cref="ArgumentNullException"><paramref name="hashing"/>
        /// or <paramref name="buffer"/> is <see langword="null"/>.</exception>
        /// <exception cref="ObjectDisposedException">
        /// <paramref name="hashing"/> object has already been disposed.</exception>
        public static void AppendData(this HashAlgorithm hashing, byte[] buffer)
        {
            _ = MethodBridge.Instance;
            IncrementalHashAlgorithm.CheckNullArg(hashing);
            hashing.AsBridge().AppendData(buffer, 0, buffer?.Length ?? 0);
        }

        /// <summary>
        /// Appends the specified data into the hash algorithm for computing the hash.
        /// </summary>
        /// <param name="hashing">The <see cref="HashAlgorithm"/>.</param>
        /// <param name="buffer">The input to compute the hash for.</param>
        /// <param name="offset">The offset into the byte array from which to begin using data.</param>
        /// <param name="count">The number of bytes in the byte array to use as data.</param>
        /// <exception cref="ArgumentNullException"><paramref name="hashing"/>
        /// or <paramref name="buffer"/> is <see langword="null"/>.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="count"/> or <paramref name="offset"/> is negative;
        /// or <paramref name="count"/> is larger than the length of <paramref name="buffer"/>.</exception>
        /// <exception cref="ArgumentException">The sum of <paramref name="offset"/>
        /// and <paramref name="count"/> is larger than the length of <paramref name="buffer"/>.</exception>
        /// <exception cref="ObjectDisposedException">
        /// <paramref name="hashing"/> object has already been disposed.</exception>
        public static void AppendData(
            this HashAlgorithm hashing, byte[] buffer, int offset, int count)
        {
            _ = MethodBridge.Instance;
            IncrementalHashAlgorithm.CheckNullArg(hashing);
            hashing.AsBridge().AppendData(buffer, offset, count);
        }

#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER
        /// <summary>
        /// Appends the specified data into the hash algorithm for computing the hash.
        /// </summary>
        /// <param name="hashing">The <see cref="HashAlgorithm"/>.</param>
        /// <param name="source">The input to compute the hash for.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="hashing"/> is <see langword="null"/>.</exception>
        /// <exception cref="ObjectDisposedException">
        /// <paramref name="hashing"/> object has already been disposed.</exception>
        public static void AppendData(this HashAlgorithm hashing, ReadOnlySpan<byte> source)
        {
            _ = MethodBridge.Instance;
            IncrementalHashAlgorithm.CheckNullArg(hashing);
            hashing.AsBridge().AppendData(source);
        }
#endif

        /// <summary>
        /// Finalizes the hash computation and retrieves the hash value.
        /// </summary>
        /// <param name="hashing">The <see cref="HashAlgorithm"/>.</param>
        /// <returns>The computed hash value.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="hashing"/> is <see langword="null"/>.</exception>
        /// <exception cref="ObjectDisposedException">
        /// <paramref name="hashing"/> object has already been disposed.</exception>
        public static byte[] GetFinalHash(this HashAlgorithm hashing)
        {
            _ = MethodBridge.Instance;
            IncrementalHashAlgorithm.CheckNullArg(hashing);
            return hashing.AsBridge().GetFinalHash();
        }

#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER
        /// <summary>
        /// Finalizes the hash computation and attempts to retrieve the hash value.
        /// </summary>
        /// <param name="hashing">The <see cref="HashAlgorithm"/>.</param>
        /// <param name="destination">The buffer to receive the hash value.</param>
        /// <param name="bytesWritten">When this method returns,
        /// the total number of bytes written into <paramref name="destination"/>.</param>
        /// <returns><see langword="true"/> if <paramref name="destination"/> is long enough
        /// to receive the hash value; otherwise, <see langword="false"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="hashing"/> is <see langword="null"/>.</exception>
        /// <exception cref="ObjectDisposedException">
        /// <paramref name="hashing"/> object has already been disposed.</exception>
        public static bool TryGetFinalHash(
            this HashAlgorithm hashing, Span<byte> destination, out int bytesWritten)
        {
            _ = MethodBridge.Instance;
            IncrementalHashAlgorithm.CheckNullArg(hashing);
            return hashing.AsBridge().TryGetFinalHash(destination, out bytesWritten);
        }
#endif

        private static void CheckNullArg(HashAlgorithm hashing)
        {
            if (hashing is null)
            {
                throw new ArgumentNullException(nameof(hashing));
            }
        }

        private static bool CheckSupported()
        {
            const string notSupportedMessage =
                $"{nameof(IncrementalHashAlgorithm)} is not supported.";
            try
            {
                using var hashing = SHA1.Create();
                hashing.Initialize();
                hashing.AppendData(Array.Empty<byte>());
                var hash = hashing.GetFinalHash();
                var hashBase64 = Convert.ToBase64String(hash);
                var result = hashBase64 == "2jmj7l5rSw0yVb/vlWAYkK/YBwk=";
#if INCRHASH_DEBUG_CHECK_SUPPORTED
                if (!result)
                {
                    Debug.Fail(notSupportedMessage);
                }
#endif
                return result;
            }
            catch (Exception ex)
            {
#if INCRHASH_DEBUG_CHECK_SUPPORTED
                Debug.Fail(notSupportedMessage, ex.Message);
#endif
                return false;
            }
        }

        [MethodImpl((MethodImplOptions)/*AggressiveInlining*/0x0100)]
        private static MethodBridge AsBridge(this HashAlgorithm hashing)
        {
#if UNSAFE_HELPERS || NETCOREAPP3_0_OR_GREATER
            return Unsafe.As<MethodBridge>(hashing);
#else
            return new UncheckedCasting() { Source = hashing }.Target!;
#endif
        }

#if !(UNSAFE_HELPERS || NETCOREAPP3_0_OR_GREATER)
        [DebuggerNonUserCode, ExcludeFromCodeCoverage]
        [StructLayout(LayoutKind.Explicit)]
        private struct UncheckedCasting
        {
            [FieldOffset(0)] public HashAlgorithm Source;
            [FieldOffset(0)] public MethodBridge Target;
            [FieldOffset(0)] public StrongBox<bool> Fields;
        }
#endif

        [DebuggerNonUserCode, ExcludeFromCodeCoverage]
        private abstract class MethodBridge : HashAlgorithm
        {
            internal static readonly MethodBridge Instance = MethodBridge.InitializeInstance();

            private static MethodBridge InitializeInstance()
            {
                var instance = (Environment.TickCount % 2 == 0) ?
                    (MethodBridge)new NonPublicMembers() : new DummyImplementation();
                instance.AppendData(Array.Empty<byte>(), 0, 0);
#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER
                instance.AppendData(ReadOnlySpan<byte>.Empty);
#endif
                _ = instance.GetFinalHash();
#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER
                _ = instance.TryGetFinalHash(Span<byte>.Empty, out _);
#endif
                return instance;
            }

            public void AppendData(byte[] buffer, int offset, int count)
            {
                this.CheckDisposed();
                this.ValidateInput(buffer, offset, count);
#if NETFRAMEWORK || NETCOREAPP3_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER || NETSTANDARD2_0_OR_GREATER
                this.State = 1;
#endif
                this.HashCore(buffer, offset, count);
            }

#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER
            public void AppendData(ReadOnlySpan<byte> source)
            {
                this.CheckDisposed();
                this.State = 1;
                this.HashCore(source);
            }
#endif

            public byte[] GetFinalHash()
            {
                this.CheckDisposed();
                var hash = this.HashFinal();
#if NETFRAMEWORK || NETCOREAPP3_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER || NETSTANDARD2_0_OR_GREATER
                this.HashValue = hash;
                this.State = 0;
#endif
                return (byte[])hash.Clone();
            }

#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER
            public bool TryGetFinalHash(Span<byte> destination, out int bytesWritten)
            {
                this.CheckDisposed();
                if (this.TryHashFinal(destination, out bytesWritten))
                {
                    this.HashValue = null;
                    this.State = 0;
                    return true;
                }
                return false;
            }
#endif

            [Conditional("INCRHASH_CHECK_DISPOSED")]
            private void CheckDisposed()
            {
#if INCRHASH_CHECK_DISPOSED
                if (NonPublicMembers.GetDisposedField(this))
                {
                    throw new ObjectDisposedException(nameof(HashAlgorithm));
                }
#endif
            }

            private void ValidateInput(byte[] buffer, int offset, int count)
            {
                if (buffer == null)
                    throw new ArgumentNullException(nameof(buffer));
                if (offset < 0)
                    throw new ArgumentOutOfRangeException(
                        nameof(offset), "Non-negative number required.");
                if ((count < 0) || (count > buffer.Length))
                    throw new ArgumentException("Value was invalid.");
                if ((buffer.Length - count) < offset)
                    throw new ArgumentException(
                        "Offset and length were out of bounds for the array " +
                        "or count is greater than the number of elements " +
                        "from index to the end of the source collection.");
            }

            [DebuggerNonUserCode, ExcludeFromCodeCoverage]
            private sealed class NonPublicMembers : MethodBridge
            {
#if INCRHASH_CHECK_DISPOSED
                private static readonly int DisposedFieldOffset =
                    NonPublicMembers.GetDisposedFieldOffset();

                private readonly bool EndField;

                [MethodImpl((MethodImplOptions)/*AggressiveInlining*/0x0100)]
                public static unsafe bool GetDisposedField(MethodBridge instance)
                {
                    if (NonPublicMembers.DisposedFieldOffset < 0) { return false; }
#if UNSAFE_HELPERS || NETCOREAPP3_0_OR_GREATER
                    var instField0 = Unsafe.As<StrongBox<bool>>(instance);
                    return Unsafe.AddByteOffset(
                        ref instField0.Value, (nint)NonPublicMembers.DisposedFieldOffset);
#else
                    var instField0 = new UncheckedCasting() { Target = instance }.Fields!;
                    fixed (bool* pField0 = &instField0.Value)
                    {
                        return pField0[NonPublicMembers.DisposedFieldOffset];
                    }
#endif
                }

                private static unsafe int GetDisposedFieldOffset()
                {
                    var instance = new NonPublicMembers();
#if UNSAFE_HELPERS || NETCOREAPP3_0_OR_GREATER
                    var instField0 = Unsafe.As<StrongBox<bool>>(instance);
#else
                    var instField0 = new UncheckedCasting() { Target = instance }.Fields!;
#endif
                    fixed (bool* pField0 = &instField0.Value, pFieldEnd = &instance.EndField)
                    {
                        var values = stackalloc bool[(int)(pFieldEnd - pField0)];
                        for (bool* pField = pField0; pField < pFieldEnd; pField++)
                        {
                            values[pField - pField0] = *pField;
                        }
                        instance.Dispose();
                        for (bool* pField = pField0; pField < pFieldEnd; pField++)
                        {
                            if (*pField && !values[pField - pField0])
                            {
                                return (int)(pField - pField0);
                            }
                        }
                    }
                    Debug.Fail("Cannot find the disposed flag field.");
                    return -1;
                }
#endif

                public override void Initialize() => throw new NotImplementedException();

                protected override void HashCore(byte[] array, int ibStart, int cbSize) { }

#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER
                protected override void HashCore(ReadOnlySpan<byte> source) { }
#endif

                protected override byte[] HashFinal() => Array.Empty<byte>();

#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER
                protected override bool TryHashFinal(
                    Span<byte> destination, out int bytesWritten) => (bytesWritten = 0) == 0;
#endif
            }

            [DebuggerNonUserCode, ExcludeFromCodeCoverage]
            private sealed class DummyImplementation : MethodBridge
            {
                [MethodImpl((MethodImplOptions)/*Synchronized*/0x0020)]
                public override void Initialize() => throw new NotImplementedException();

                [MethodImpl((MethodImplOptions)/*Synchronized*/0x0020)]
                protected override void HashCore(byte[] array, int ibStart, int cbSize) { }

#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER
                [MethodImpl((MethodImplOptions)/*Synchronized*/0x0020)]
                protected override void HashCore(ReadOnlySpan<byte> source) { }
#endif

                [MethodImpl((MethodImplOptions)/*Synchronized*/0x0020)]
                protected override byte[] HashFinal() => Array.Empty<byte>();

#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER
                [MethodImpl((MethodImplOptions)/*Synchronized*/0x0020)]
                protected override bool TryHashFinal(
                    Span<byte> destination, out int bytesWritten) => (bytesWritten = 0) == 0;
#endif
            }
        }
    }
}

#if !(EXCLUDE_FROM_CODE_COVERAGE_ATTRIBUTE || NETCOREAPP3_0_OR_GREATER)
#if !(NET40_OR_GREATER || NETCOREAPP2_0_OR_GREATER || NETSTANDARD2_0_OR_GREATER)
namespace System.Diagnostics.CodeAnalysis
{
    // Excludes the attributed code from code coverage information.
    internal sealed partial class ExcludeFromCodeCoverageAttribute : Attribute
    {
    }
}
#endif
#endif
